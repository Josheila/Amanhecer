{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/sheilazhai/Library/Mobile%20Documents/com~apple~CloudDocs/Amanhecer/node_modules/.pnpm/refractor%403.6.0/node_modules/refractor/lang/scheme.js"],"sourcesContent":["'use strict'\n\nmodule.exports = scheme\nscheme.displayName = 'scheme'\nscheme.aliases = []\nfunction scheme(Prism) {\n  ;(function (Prism) {\n    Prism.languages.scheme = {\n      // this supports \"normal\" single-line comments:\n      //   ; comment\n      // and (potentially nested) multiline comments:\n      //   #| comment #| nested |# still comment |#\n      // (only 1 level of nesting is supported)\n      comment:\n        /;.*|#;\\s*(?:\\((?:[^()]|\\([^()]*\\))*\\)|\\[(?:[^\\[\\]]|\\[[^\\[\\]]*\\])*\\])|#\\|(?:[^#|]|#(?!\\|)|\\|(?!#)|#\\|(?:[^#|]|#(?!\\|)|\\|(?!#))*\\|#)*\\|#/,\n      string: {\n        pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n        greedy: true\n      },\n      symbol: {\n        pattern: /'[^()\\[\\]#'\\s]+/,\n        greedy: true\n      },\n      char: {\n        pattern:\n          /#\\\\(?:[ux][a-fA-F\\d]+\\b|[-a-zA-Z]+\\b|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|\\S)/,\n        greedy: true\n      },\n      'lambda-parameter': [\n        // https://www.cs.cmu.edu/Groups/AI/html/r4rs/r4rs_6.html#SEC30\n        {\n          pattern:\n            /((?:^|[^'`#])[(\\[]lambda\\s+)(?:[^|()\\[\\]'\\s]+|\\|(?:[^\\\\|]|\\\\.)*\\|)/,\n          lookbehind: true\n        },\n        {\n          pattern: /((?:^|[^'`#])[(\\[]lambda\\s+[(\\[])[^()\\[\\]']+/,\n          lookbehind: true\n        }\n      ],\n      keyword: {\n        pattern:\n          /((?:^|[^'`#])[(\\[])(?:begin|case(?:-lambda)?|cond(?:-expand)?|define(?:-library|-macro|-record-type|-syntax|-values)?|defmacro|delay(?:-force)?|do|else|except|export|guard|if|import|include(?:-ci|-library-declarations)?|lambda|let(?:rec)?(?:-syntax|-values|\\*)?|let\\*-values|only|parameterize|prefix|(?:quasi-?)?quote|rename|set!|syntax-(?:case|rules)|unless|unquote(?:-splicing)?|when)(?=[()\\[\\]\\s]|$)/,\n        lookbehind: true\n      },\n      builtin: {\n        // all functions of the base library of R7RS plus some of built-ins of R5Rs\n        pattern:\n          /((?:^|[^'`#])[(\\[])(?:abs|and|append|apply|assoc|ass[qv]|binary-port\\?|boolean=?\\?|bytevector(?:-append|-copy|-copy!|-length|-u8-ref|-u8-set!|\\?)?|caar|cadr|call-with-(?:current-continuation|port|values)|call\\/cc|car|cdar|cddr|cdr|ceiling|char(?:->integer|-ready\\?|\\?|<\\?|<=\\?|=\\?|>\\?|>=\\?)|close-(?:input-port|output-port|port)|complex\\?|cons|current-(?:error|input|output)-port|denominator|dynamic-wind|eof-object\\??|eq\\?|equal\\?|eqv\\?|error|error-object(?:-irritants|-message|\\?)|eval|even\\?|exact(?:-integer-sqrt|-integer\\?|\\?)?|expt|features|file-error\\?|floor(?:-quotient|-remainder|\\/)?|flush-output-port|for-each|gcd|get-output-(?:bytevector|string)|inexact\\??|input-port(?:-open\\?|\\?)|integer(?:->char|\\?)|lcm|length|list(?:->string|->vector|-copy|-ref|-set!|-tail|\\?)?|make-(?:bytevector|list|parameter|string|vector)|map|max|member|memq|memv|min|modulo|negative\\?|newline|not|null\\?|number(?:->string|\\?)|numerator|odd\\?|open-(?:input|output)-(?:bytevector|string)|or|output-port(?:-open\\?|\\?)|pair\\?|peek-char|peek-u8|port\\?|positive\\?|procedure\\?|quotient|raise|raise-continuable|rational\\?|rationalize|read-(?:bytevector|bytevector!|char|error\\?|line|string|u8)|real\\?|remainder|reverse|round|set-c[ad]r!|square|string(?:->list|->number|->symbol|->utf8|->vector|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\\?|<\\?|<=\\?|=\\?|>\\?|>=\\?)?|substring|symbol(?:->string|\\?|=\\?)|syntax-error|textual-port\\?|truncate(?:-quotient|-remainder|\\/)?|u8-ready\\?|utf8->string|values|vector(?:->list|->string|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\\?)?|with-exception-handler|write-(?:bytevector|char|string|u8)|zero\\?)(?=[()\\[\\]\\s]|$)/,\n        lookbehind: true\n      },\n      operator: {\n        pattern: /((?:^|[^'`#])[(\\[])(?:[-+*%/]|[<>]=?|=>?)(?=[()\\[\\]\\s]|$)/,\n        lookbehind: true\n      },\n      number: {\n        // The number pattern from [the R7RS spec](https://small.r7rs.org/attachment/r7rs.pdf).\n        //\n        // <number>      := <num 2>|<num 8>|<num 10>|<num 16>\n        // <num R>       := <prefix R><complex R>\n        // <complex R>   := <real R>(?:@<real R>|<imaginary R>)?|<imaginary R>\n        // <imaginary R> := [+-](?:<ureal R>|(?:inf|nan)\\.0)?i\n        // <real R>      := [+-]?<ureal R>|[+-](?:inf|nan)\\.0\n        // <ureal R>     := <uint R>(?:\\/<uint R>)?\n        //                | <decimal R>\n        //\n        // <decimal 10>  := (?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?\n        // <uint R>      := <digit R>+\n        // <prefix R>    := <radix R>(?:#[ei])?|(?:#[ei])?<radix R>\n        // <radix 2>     := #b\n        // <radix 8>     := #o\n        // <radix 10>    := (?:#d)?\n        // <radix 16>    := #x\n        // <digit 2>     := [01]\n        // <digit 8>     := [0-7]\n        // <digit 10>    := \\d\n        // <digit 16>    := [0-9a-f]\n        //\n        // The problem with this grammar is that the resulting regex is way to complex, so we simplify by grouping all\n        // non-decimal bases together. This results in a decimal (dec) and combined binary, octal, and hexadecimal (box)\n        // pattern:\n        pattern: RegExp(\n          SortedBNF({\n            '<ureal dec>':\n              /\\d+(?:\\/\\d+)|(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[esfdl][+-]?\\d+)?/.source,\n            '<real dec>': /[+-]?<ureal dec>|[+-](?:inf|nan)\\.0/.source,\n            '<imaginary dec>': /[+-](?:<ureal dec>|(?:inf|nan)\\.0)?i/.source,\n            '<complex dec>':\n              /<real dec>(?:@<real dec>|<imaginary dec>)?|<imaginary dec>/\n                .source,\n            '<num dec>': /(?:#d(?:#[ei])?|#[ei](?:#d)?)?<complex dec>/.source,\n            '<ureal box>': /[0-9a-f]+(?:\\/[0-9a-f]+)?/.source,\n            '<real box>': /[+-]?<ureal box>|[+-](?:inf|nan)\\.0/.source,\n            '<imaginary box>': /[+-](?:<ureal box>|(?:inf|nan)\\.0)?i/.source,\n            '<complex box>':\n              /<real box>(?:@<real box>|<imaginary box>)?|<imaginary box>/\n                .source,\n            '<num box>': /#[box](?:#[ei])?|(?:#[ei])?#[box]<complex box>/\n              .source,\n            '<number>': /(^|[()\\[\\]\\s])(?:<num dec>|<num box>)(?=[()\\[\\]\\s]|$)/\n              .source\n          }),\n          'i'\n        ),\n        lookbehind: true\n      },\n      boolean: {\n        pattern: /(^|[()\\[\\]\\s])#(?:[ft]|false|true)(?=[()\\[\\]\\s]|$)/,\n        lookbehind: true\n      },\n      function: {\n        pattern:\n          /((?:^|[^'`#])[(\\[])(?:[^|()\\[\\]'\\s]+|\\|(?:[^\\\\|]|\\\\.)*\\|)(?=[()\\[\\]\\s]|$)/,\n        lookbehind: true\n      },\n      identifier: {\n        pattern: /(^|[()\\[\\]\\s])\\|(?:[^\\\\|]|\\\\.)*\\|(?=[()\\[\\]\\s]|$)/,\n        lookbehind: true,\n        greedy: true\n      },\n      punctuation: /[()\\[\\]']/\n    }\n    /**\n     * Given a topologically sorted BNF grammar, this will return the RegExp source of last rule of the grammar.\n     *\n     * @param {Record<string, string>} grammar\n     * @returns {string}\n     */\n    function SortedBNF(grammar) {\n      for (var key in grammar) {\n        grammar[key] = grammar[key].replace(/<[\\w\\s]+>/g, function (key) {\n          return '(?:' + grammar[key].trim() + ')'\n        })\n      } // return the last item\n      return grammar[key]\n    }\n  })(Prism)\n}\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG;AACjB,OAAO,WAAW,GAAG;AACrB,OAAO,OAAO,GAAG,EAAE;AACnB,SAAS,OAAO,KAAK;;IAClB,CAAC,SAAU,KAAK;QACf,MAAM,SAAS,CAAC,MAAM,GAAG;YACvB,+CAA+C;YAC/C,cAAc;YACd,+CAA+C;YAC/C,6CAA6C;YAC7C,yCAAyC;YACzC,SACE;YACF,QAAQ;gBACN,SAAS;gBACT,QAAQ;YACV;YACA,QAAQ;gBACN,SAAS;gBACT,QAAQ;YACV;YACA,MAAM;gBACJ,SACE;gBACF,QAAQ;YACV;YACA,oBAAoB;gBAClB,+DAA+D;gBAC/D;oBACE,SACE;oBACF,YAAY;gBACd;gBACA;oBACE,SAAS;oBACT,YAAY;gBACd;aACD;YACD,SAAS;gBACP,SACE;gBACF,YAAY;YACd;YACA,SAAS;gBACP,2EAA2E;gBAC3E,SACE;gBACF,YAAY;YACd;YACA,UAAU;gBACR,SAAS;gBACT,YAAY;YACd;YACA,QAAQ;gBACN,uFAAuF;gBACvF,EAAE;gBACF,qDAAqD;gBACrD,yCAAyC;gBACzC,sEAAsE;gBACtE,sDAAsD;gBACtD,qDAAqD;gBACrD,2CAA2C;gBAC3C,+BAA+B;gBAC/B,EAAE;gBACF,yDAAyD;gBACzD,8BAA8B;gBAC9B,2DAA2D;gBAC3D,sBAAsB;gBACtB,sBAAsB;gBACtB,2BAA2B;gBAC3B,sBAAsB;gBACtB,wBAAwB;gBACxB,yBAAyB;gBACzB,sBAAsB;gBACtB,4BAA4B;gBAC5B,EAAE;gBACF,8GAA8G;gBAC9G,gHAAgH;gBAChH,WAAW;gBACX,SAAS,OACP,UAAU;oBACR,eACE,2DAA2D,MAAM;oBACnE,cAAc,sCAAsC,MAAM;oBAC1D,mBAAmB,uCAAuC,MAAM;oBAChE,iBACE,6DACG,MAAM;oBACX,aAAa,8CAA8C,MAAM;oBACjE,eAAe,4BAA4B,MAAM;oBACjD,cAAc,sCAAsC,MAAM;oBAC1D,mBAAmB,uCAAuC,MAAM;oBAChE,iBACE,6DACG,MAAM;oBACX,aAAa,iDACV,MAAM;oBACT,YAAY,wDACT,MAAM;gBACX,IACA;gBAEF,YAAY;YACd;YACA,SAAS;gBACP,SAAS;gBACT,YAAY;YACd;YACA,UAAU;gBACR,SACE;gBACF,YAAY;YACd;YACA,YAAY;gBACV,SAAS;gBACT,YAAY;gBACZ,QAAQ;YACV;YACA,aAAa;QACf;QACA;;;;;KAKC,GACD,SAAS,UAAU,OAAO;YACxB,IAAK,IAAI,OAAO,QAAS;gBACvB,OAAO,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,cAAc,SAAU,GAAG;oBAC7D,OAAO,QAAQ,OAAO,CAAC,IAAI,CAAC,IAAI,KAAK;gBACvC;YACF,EAAE,uBAAuB;YACzB,OAAO,OAAO,CAAC,IAAI;QACrB;IACF,CAAC,EAAE;AACL","ignoreList":[0]}},
    {"offset": {"line": 128, "column": 0}, "map": {"version":3,"sources":["file:///Users/sheilazhai/Library/Mobile%20Documents/com~apple~CloudDocs/Amanhecer/node_modules/.pnpm/refractor%403.6.0/node_modules/refractor/lang/lilypond.js"],"sourcesContent":["'use strict'\nvar refractorScheme = require('./scheme.js')\nmodule.exports = lilypond\nlilypond.displayName = 'lilypond'\nlilypond.aliases = []\nfunction lilypond(Prism) {\n  Prism.register(refractorScheme)\n  ;(function (Prism) {\n    var schemeExpression =\n      /\\((?:[^();\"#\\\\]|\\\\[\\s\\S]|;.*(?!.)|\"(?:[^\"\\\\]|\\\\.)*\"|#(?:\\{(?:(?!#\\})[\\s\\S])*#\\}|[^{])|<expr>)*\\)/\n        .source // allow for up to pow(2, recursivenessLog2) many levels of recursive brace expressions\n    // For some reason, this can't be 4\n    var recursivenessLog2 = 5\n    for (var i = 0; i < recursivenessLog2; i++) {\n      schemeExpression = schemeExpression.replace(/<expr>/g, function () {\n        return schemeExpression\n      })\n    }\n    schemeExpression = schemeExpression.replace(/<expr>/g, /[^\\s\\S]/.source)\n    var lilypond = (Prism.languages.lilypond = {\n      comment: /%(?:(?!\\{).*|\\{[\\s\\S]*?%\\})/,\n      'embedded-scheme': {\n        pattern: RegExp(\n          /(^|[=\\s])#(?:\"(?:[^\"\\\\]|\\\\.)*\"|[^\\s()\"]*(?:[^\\s()]|<expr>))/.source.replace(\n            /<expr>/g,\n            function () {\n              return schemeExpression\n            }\n          ),\n          'm'\n        ),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          scheme: {\n            pattern: /^(#)[\\s\\S]+$/,\n            lookbehind: true,\n            alias: 'language-scheme',\n            inside: {\n              'embedded-lilypond': {\n                pattern: /#\\{[\\s\\S]*?#\\}/,\n                greedy: true,\n                inside: {\n                  punctuation: /^#\\{|#\\}$/,\n                  lilypond: {\n                    pattern: /[\\s\\S]+/,\n                    alias: 'language-lilypond',\n                    inside: null // see below\n                  }\n                }\n              },\n              rest: Prism.languages.scheme\n            }\n          },\n          punctuation: /#/\n        }\n      },\n      string: {\n        pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n        greedy: true\n      },\n      'class-name': {\n        pattern: /(\\\\new\\s+)[\\w-]+/,\n        lookbehind: true\n      },\n      keyword: {\n        pattern: /\\\\[a-z][-\\w]*/i,\n        inside: {\n          punctuation: /^\\\\/\n        }\n      },\n      operator: /[=|]|<<|>>/,\n      punctuation: {\n        pattern:\n          /(^|[a-z\\d])(?:'+|,+|[_^]?-[_^]?(?:[-+^!>._]|(?=\\d))|[_^]\\.?|[.!])|[{}()[\\]<>^~]|\\\\[()[\\]<>\\\\!]|--|__/,\n        lookbehind: true\n      },\n      number: /\\b\\d+(?:\\/\\d+)?\\b/\n    })\n    lilypond['embedded-scheme'].inside['scheme'].inside[\n      'embedded-lilypond'\n    ].inside['lilypond'].inside = lilypond\n    Prism.languages.ly = lilypond\n  })(Prism)\n}\n"],"names":[],"mappings":"AACA,IAAI;AACJ,OAAO,OAAO,GAAG;AACjB,SAAS,WAAW,GAAG;AACvB,SAAS,OAAO,GAAG,EAAE;AACrB,SAAS,SAAS,KAAK;IACrB,MAAM,QAAQ,CAAC;IACd,CAAC,SAAU,KAAK;QACf,IAAI,mBACF,mGACG,MAAM,CAAC,uFAAuF;;QACnG,mCAAmC;QACnC,IAAI,oBAAoB;QACxB,IAAK,IAAI,IAAI,GAAG,IAAI,mBAAmB,IAAK;YAC1C,mBAAmB,iBAAiB,OAAO,CAAC,WAAW;gBACrD,OAAO;YACT;QACF;QACA,mBAAmB,iBAAiB,OAAO,CAAC,WAAW,UAAU,MAAM;QACvE,IAAI,WAAY,MAAM,SAAS,CAAC,QAAQ,GAAG;YACzC,SAAS;YACT,mBAAmB;gBACjB,SAAS,OACP,8DAA8D,MAAM,CAAC,OAAO,CAC1E,WACA;oBACE,OAAO;gBACT,IAEF;gBAEF,YAAY;gBACZ,QAAQ;gBACR,QAAQ;oBACN,QAAQ;wBACN,SAAS;wBACT,YAAY;wBACZ,OAAO;wBACP,QAAQ;4BACN,qBAAqB;gCACnB,SAAS;gCACT,QAAQ;gCACR,QAAQ;oCACN,aAAa;oCACb,UAAU;wCACR,SAAS;wCACT,OAAO;wCACP,QAAQ,KAAK,YAAY;oCAC3B;gCACF;4BACF;4BACA,MAAM,MAAM,SAAS,CAAC,MAAM;wBAC9B;oBACF;oBACA,aAAa;gBACf;YACF;YACA,QAAQ;gBACN,SAAS;gBACT,QAAQ;YACV;YACA,cAAc;gBACZ,SAAS;gBACT,YAAY;YACd;YACA,SAAS;gBACP,SAAS;gBACT,QAAQ;oBACN,aAAa;gBACf;YACF;YACA,UAAU;YACV,aAAa;gBACX,SACE;gBACF,YAAY;YACd;YACA,QAAQ;QACV;QACA,QAAQ,CAAC,kBAAkB,CAAC,MAAM,CAAC,SAAS,CAAC,MAAM,CACjD,oBACD,CAAC,MAAM,CAAC,WAAW,CAAC,MAAM,GAAG;QAC9B,MAAM,SAAS,CAAC,EAAE,GAAG;IACvB,CAAC,EAAE;AACL","ignoreList":[0]}}]
}